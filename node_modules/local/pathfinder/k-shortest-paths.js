'use strict';

var MAX_TIME = 2000;

module.exports = yensAlgorithm;

var priorityShortestPath = require('./priority-shortest-path.js');

function yensAlgorithm(graph, sourceId, sinkId, numPaths, priorityFunc, maxBridges, maxTime) {
    if (maxBridges === undefined) maxBridges = 2;
    if (!maxTime) maxTime = MAX_TIME;
    if (!numPaths) numPaths = 20;
    
    var generatedPaths = [];
    var solvedCombinations = [];
    var initialTime = Date.now();
    var hasStatic = false;

    while (generatedPaths.length < numPaths && initialTime + maxTime > Date.now()) {
        
        // skip over input parameters that have already been solved
        for (var i = 0; i < solvedCombinations.length; i++) {
            var combi = solvedCombinations[i];

            var brs = combi.bridges.every(function (x) {
                return !graph.bridgeIsForbidden(x);
            });
            var whs = combi.wormholes.every(function (x) {
                return !graph.wormholeIsForbidden(x);
            });

            if (brs && whs) {
                if (combi.bridges.length > 0) {
                    graph.forbidBridge(combi.bridges[combi.bridges.length - 1]);
                }
                else {
                    graph.forbidWormhole(combi.wormholes[combi.wormholes.length -1]);
                }
            }
        }
        if (brs && whs) continue;

        var path = priorityShortestPath(graph, sourceId, sinkId, priorityFunc);

        graph.clearForbidden();

        if (!path) break;

        var combi = createSolvedCombination(path);
        solvedCombinations.push(combi);
        
        if (countBridges(path) <= maxBridges) {
            generatedPaths.push(path);
        }

        if (combi.wormholes.length === 0 && combi.bridges.length === 0) {
            hasStatic = true;
            break;
        }
    }

    if (!hasStatic) {
        graph = graph.copy();
        graph.bridges = [];
        graph.wormholes = [];
        var staticPath = priorityShortestPath(graph, sourceId, sinkId, priorityFunc);
        
        

        if (staticPath) generatedPaths.push(staticPath);
    }
    
    generatedPaths = generatedPaths.sort(function (a, b) {
        if (a.length === b.length) return 0;
        return a.length < b.length ? -1 : 1;
    });
    return generatedPaths;
}
function countBridges(path) {
    var count = 0;
    for (var i = 0; i < path.length; i++) {
        if (path[i].methodType === "bridge") count++;
    }
    return count;
}
function createSolvedCombination(path) {
    var wormholesInPath = path.filter(function (node) {
        return node.methodType == "wormhole";
    }).map(function (node) { return node.methodData.id; });
    var bridgersInPath = path.filter(function (node) {
        return node.methodType == "bridge";
    }).map(function (node) { return node.methodData.id; });

    return { wormholes: wormholesInPath, bridges: bridgersInPath };
}

///**
// * Helper to work out whether each new shortest path is interesting or not. 
// */
//function InterestingPaths() {
//    this.data = [];
//    this.fragmentCache = [];
//}
//InterestingPaths.prototype.length = function () {
//    return this.data.length;
//}
//InterestingPaths.prototype.push = function (path) {
//    this.addToFragmentCache(path);
//    this.data.push(path);
//}
//InterestingPaths.prototype.isDistinct = function (newPath) {
//    var parts = splitByWormhole(newPath);
//    var frag = extractFragment(parts);

//    var notDistinct = this.fragmentCache.some(function (x) {
//        return fragmentEquality(frag, x);
//    });
//    return !notDistinct;
//}
//InterestingPaths.prototype.addToFragmentCache = function (path) {
//    var parts = splitByWormhole(path);
//    var frag = extractFragment(parts);

//    this.fragmentCache.push(frag);
//}

//function splitByWormhole(path) {
//    var output = [];

//    var partIndex = undefined;
//    for (var i = 1; i < path.length; i++) {
//        var node = path[i];
//        if (node.methodType !== "wormhole") {
//            if (partIndex === undefined)
//                partIndex = i - 1;
//        }
//        else if (partIndex !== undefined) {
//            output.push(path.slice(partIndex, i));
//            partIndex = undefined;
//        }
//    }
//    if (partIndex !== undefined) output.push(path.slice(partIndex));

//    return output;
//}
//function countBridges(path) {
//    var count = 0;
//    for (var i = 0; i < path.length; i++) {
//        if (path[i].methodType === "bridge") count++;
//    }
//    return count;
//}
//function hasBridges(path) {
//    for (var i = 0; i < path.length; i++) {
//        if (path[i].methodType === "bridge") return true;
//    }
//    return false;
//}

//function extractFragment(parts) {
//    return parts.map(function (x) {
//        return {
//            s: x[0].id,
//            e: x[x.length - 1].id
//        }
//    });
//}
//function fragmentEquality(frag1, frag2) {
//    if (frag1.length !== frag2.length) return false;
//    for (var i = 0; i < frag1.length; i++) {
//        if (frag1.s !== frag2.s || frag1.e !== frag2.e) return false;
//    }
//    return true;
//}
