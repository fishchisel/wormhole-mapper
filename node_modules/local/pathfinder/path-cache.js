'use strict';

var pathCache = {};
module.exports = pathCache;

/**
 * Cache of static paths created by the pathfinder.
 *
 * Note that null means no path possible, undefined means no path yet present.
 *
 * functions:
 *      hasPath
 *      hasJumpCount
 *      getPath
 *      getJumpCount
 *      setPath
 *      setJumpCount
 *      clearCache
 *      countCachedPaths
 *      countCachedJumps
 */


var Node = require('./node.js'),
    sysRep = require('local/repositories/system');

// see browser sections of package.json
var store = require('./store');

pathCache.hasPath = function (args) {
    var path = getCachedData(args).getPath(!args.noHighsec, !args.noLowsec, !args.noNullsec);
    return path !== undefined;
}

pathCache.hasJumpCount = function (args) {
    var path = getCachedData(args).getJumps(!args.noHighsec, !args.noLowsec, !args.noNullsec);
    return path !== undefined;
}

pathCache.getPath = function (args) {
    var pathData = getCachedData(args).getPath(!args.noHighsec, !args.noLowsec, !args.noNullsec);
    if (!pathData) return pathData;
    return toNodeArray(pathData);
}
pathCache.getJumpCount = function (args) {
    return getCachedData(args).getJumps(!args.noHighsec, !args.noLowsec, !args.noNullsec);
}

pathCache.setPath = function (path, args) {
    var staticPathRecord = getCachedData(args);
    if (path) path = toIdArray(path);
    staticPathRecord.setPath(path, !args.noHighsec, !args.noLowsec, !args.noNullsec);
    setCachedData(staticPathRecord, args);
}

pathCache.setJumpCount = function (jumps, args) {
    var staticPathRecord = getCachedData(args);
    staticPathRecord.setJumps(jumps, !args.noHighsec, !args.noLowsec, !args.noNullsec);
    setCachedData(staticPathRecord, args);
}

pathCache.clearCache = function () {
    store.clear();
}
pathCache.countCachedPaths = function () {
    var res = store.getAll();

    var count = Object.keys(res).reduce(function (total, key) {
        var item = res[key];
        var record = new StaticPathRecord(item);
        return total + record.countCachedPaths();
    }, 0);

    return count;
}
pathCache.countCachedJumps = function () {
    var res = store.getAll();

    var count = Object.keys(res).reduce(function (total, key) {
        var item = res[key];
        var record = new StaticPathRecord(item);
        return total + record.countCachedJumps();
    }, 0);

    return count;
}


function getCachedData(args) {
    var id = "static_" + args.startSys.id + "_" + args.endSys.id;

    var record = new StaticPathRecord(store.get(id));
    return record;
}
function setCachedData(staticDataRecord, args) {
    var id = "static_" + args.startSys.id + "_" + args.endSys.id;
    store.set(id, staticDataRecord.data);
}

function toNodeArray(idArray) {
    return idArray.map(function(id) {
        var sys = sysRep.getSystem(id);
        return new Node(sys,"gate");
    });
}
function toIdArray(nodeArray) {
    return nodeArray.map(function(x) { return x.id; });
}


/**
 * Represents all the cached path data for paths between two systems. Paths are stored in the
 * cache as an array of systemIds
 */
function StaticPathRecord (data) {
    this.data = data ? data : {};
}
StaticPathRecord.prototype.getPath = function (hi, lo, nl) {
    var key = _makeKey(hi, lo, nl) + "_route";
    return this.data[key];
}
StaticPathRecord.prototype.setPath = function (route, hi, lo, nl) {
    var key = _makeKey(hi, lo, nl) + "_route";
    this.data[key] = route;
}
StaticPathRecord.prototype.getJumps = function (hi, lo, nl) {
    var key = _makeKey(hi, lo, nl) + "_jumps";
    return this.data[key];
}
StaticPathRecord.prototype.setJumps = function (jumps, hi, lo, nl) {
    var key = _makeKey(hi, lo, nl) + "_jumps";
    this.data[key] = jumps;
}
StaticPathRecord.prototype.countCachedPaths = function () {
    return this.countCached("route");
}
StaticPathRecord.prototype.countCachedJumps = function () {
    return this.countCached("jumps");
}
StaticPathRecord.prototype.countCached = function (type) {
    var keys = Object.keys(this.data);
    var count = keys.reduce(function (total, key) {
        var isRoute = key.indexOf(type) > -1;
        return isRoute ? total + 1 : total;
    }, 0);
    return count;
}

function _makeKey(hi, lo, nl) {
    hi = hi ? 1 : 0;
    lo = lo ? 1 : 0;
    nl = nl ? 1 : 0;
    return hi + "_" + lo + "_" + nl;
}
