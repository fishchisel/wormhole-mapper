'use strict';

var sysRep = require('local/repositories/system');

var pathCache = require('./path-cache.js'),
    shortestPath = require('./priority-shortest-path.js'),
    Graph = require('./graph.js'),
    RouteDetails = require('./route-details.js'),
    kShortestPaths = require('./k-shortest-paths.js'),
    shortestDistances = require('./priority-shortest-distances.js');

var q = require('q');

var me = {};
module.exports = me;

/**
 * Finds paths betwen two systems, including the shortest path and the static path. Returns
 * a promise.
 * args: {
 *      startSys,       // System object
 *      endSys,         // System object
 *      wormholes,      // Array of Wormhole objects
 *      bridges,        // Array of Bridge objects
 *      highsec,        // 0,1,2 : permit, avoid, exclude
 *      lowsec,         // 0,1,2 : permit, avoid, exclude
 *      nullsec,        // 0,1,2 : permit, avoid, exclude
 *      wspace,         // 0,1,2 : permit, avoid, exclude
 *      maxPaths,       // int > 0
 *      maxBridges,     // int > 0
 *      maxTime,        // milliseconds
 *      minBridgeDistance // int > 0, equiv jumps
 * }
 */
me.findPaths = function (args) {
    if (!args.maxPaths) args.maxPaths = 20;

    return sysRep.initialize().then(function() {
        var excludes = {
            hi: args.highsec === 2,
            lo: args.lowsec === 2,
            nl: args.nullsec === 2,
            ws: args.wspace === 2
        }
        var graph = new Graph(args.wormholes, args.bridges, excludes, args.minBridgeDistance);
        var lowPriorityFunc = function (x) {
            if (args.highsec === 1 && x.system.isHighsec()) return true;
            if (args.lowsec === 1 && x.system.isHighsec()) return true;
            if (args.nullsec === 1 && x.system.isHighsec()) return true;
            if (args.wspace === 1 && x.system.isHighsec()) return true;
            return false;
        };
        var sourceId = args.startSys.id;
        var sinkId = args.endSys.id;

        var results = kShortestPaths(graph, sourceId, sinkId, args.maxPaths, lowPriorityFunc,
                                    args.maxBridges, args.maxTime);


        results = results.map(function (x) { return new RouteDetails(x); });
        return results;
    })    
}

/**
 * Finds distances from the start system to all other systems.
 * args: {
 *      startSys,       // System object
 *      wormholes,      // Array of Wormhole objects
 *      bridges,        // Array of Bridge objects
 *      highsec,        // 0,1,2 : permit, avoid, exclude
 *      lowsec,         // 0,1,2 : permit, avoid, exclude
 *      nullsec,        // 0,1,2 : permit, avoid, exclude
 *      wspace,         // 0,1,2 : permit, avoid, exclude
 *      maxLength,       // int > 0
 *      maxBridges,     // int > 0
 *      minBridgeDistance // int > 0, equiv jumps
 * }
 */
me.findDistances = function (args) {
    return sysRep.initialize().then(function () {
        var excludes = {
            hi: args.highsec === 2,
            lo: args.lowsec === 2,
            nl: args.nullsec === 2,
            ws: args.wspace === 2
        }
        var graph = new Graph(args.wormholes, args.bridges, excludes, args.minBridgeDistance);
        var lowPriorityFunc = function (x) {
            if (args.highsec === 1 && x.system.isHighsec()) return true;
            if (args.lowsec === 1 && x.system.isHighsec()) return true;
            if (args.nullsec === 1 && x.system.isHighsec()) return true;
            if (args.wspace === 1 && x.system.isHighsec()) return true;
            return false;
        };
        var sourceId = args.startSys.id;

        var results = shortestDistances(graph, sourceId, lowPriorityFunc, args.maxLength);

        return results;
    })
}


/**
 * Finds a static path.
 *
 * args: { startSys: {system object},
 *         endSys: {system object},
 *         noHighsec: bool,
 *         noLowsec: bool,
 *         noNullsec: bool
 *       }
 */
me.findStaticPath = function (args) {
    if (!pathCache.hasPath(args)) {
        var path = getStaticPath(args);
        pathCache.setPath(path, args);
    }
    var outPath = pathCache.getPath(args);
    if (!outPath) return outPath;
    return new RouteDetails(outPath);
};

/**
 * Finds jump count of a static path. Sysrep should be initialized.
 *
 * args: { startSys: {system object},
 *         endSys: {system object},
 *         noHighsec: bool,
 *         noLowsec: bool,
 *         noNullsec: bool
 *       }
 */
me.findStaticJumpCount = function (args) {

    if (!pathCache.hasJumpCount(args)) {
        var path = getStaticPath(args);
        var jumps = path ? path.length - 1 : null;

        pathCache.setJumpCount(jumps, args);
    }
    return pathCache.getJumpCount(args);
};



function getStaticPath(args) {

    var graph = new Graph(null, null, {
        hi: args.noHighsec,
        lo: args.noLowsec,
        nl: args.noNullsec
    });

    return shortestPath(graph, args.startSys.id, args.endSys.id);
}