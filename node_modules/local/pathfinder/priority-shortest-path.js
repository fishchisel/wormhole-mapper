'use strict';

module.exports = search;

var TwoPriorityQueue = require('./two-priority-queue.js');

var MAX_LENGTH = 100;

/**
 * Finds the shortest path between two nodes in the graph.
 *
 * graph: a Graph for providing connections
 * sourceId,sinkId: start and finish of the path
 * priorityFunc: function to identify lowPriorityNodes in the form 
 *                   function(node) { }
 *               should return true if the node is low priority
 * maxLength: number > 0
 */
function search(graph, sourceId, sinkId, priorityFunc,maxLength) {
    if (sourceId === sinkId) return null;
    if (maxLength === 0) return null;

    if (!priorityFunc) priorityFunc = function (a) { return false; }
    if (!maxLength) maxLength = MAX_LENGTH;

    var openList = new TwoPriorityQueue(priorityFunc);

    var closedList = {};

    var startNode = graph.getNode(sourceId);
    openList.enq(startNode);
    closedList[startNode.id] = true;
    startNode.distance = 0;

    while (!openList.isEmpty()) {

        var currentNode = openList.deq();

        if (currentNode.distance > maxLength) continue;

        if (currentNode.id === sinkId) return makePath(currentNode);

        var connectedNodes = graph.getConnectedNodes(currentNode.id);
        for (var i = 0; i < connectedNodes.length; i++) {
            var connectedNode = connectedNodes[i];
            if (closedList[connectedNode.id]) continue;

            connectedNode.distance = currentNode.distance + 1;
            connectedNode.parent = currentNode;

            openList.enq(connectedNode);
            closedList[connectedNode.id] = true;
        }
    }
    return null;
}

function makePath(endNode) {
    var out = [endNode];
    var curr = endNode.parent;
    while (curr) {
        out.push(curr);
        curr = curr.parent;
    }
    return out.reverse();
}