'use strict';

var moment = require('moment');

/**
    * Constructs a RouteDetails object (providing various data about a given route) from an array
    * of route nodes in this format:
    * [
    *   {
    *       system: { } // System object
    *       methodType: '' // one of 'stargate', 'bridge', 'wormhole' or undefined if root.
    *       method: {} // a wormhole or bridge object, or undefined if root/stargate
    *   }
    * ]
    */
function RouteDetails (route) {
	this.route = route;

	this.routePartition = this.getPartition(route);

	this.startSystem = route[0].system;
	this.endSystem = route[route.length - 1].system;

	this.jumps = route.length - 1;
		
	this.goesHighsec = route.some(function (item) { return item.system.isHighsec() });
	this.goesLowsec = route.some(function (item) { return item.system.isLowsec() });
	this.goesNullsec = route.some(function (item) { return item.system.isNullsec() });
	this.goesWspace = route.some(function (item) { return item.system.isWormholeSpace(); });

	this.hasBridges = this.route.some(function (item) { return item.methodType === "bridge"; });
	this.hasStargates = this.route.some(function (item) { return item.methodType === "gate"; });
	this.hasWormholes = this.route.some(function (item) { return item.methodType === "wormhole"; });

	this.hasTitans = this.route.some(function (item) {
		return item.methodType === "bridge" && item.methodData.bridgeType === "titan";
	});
	this.hasBlackops = this.route.some(function (item) {
	    return item.methodType === "bridge" && item.methodData.bridgeType === "blackops";
	});
};
RouteDetails.prototype.getPartition = function (route) {
	var partitionList = [];

	var partition = [];
	var currentMethodType;
	partition.push(route[0]);
	for (var i = 1; i < route.length; i++) {
		var currentRouteNode = route[i];
		var methodType = currentRouteNode.methodType;
		if (methodType === "wormhole") {
		    methodType = currentRouteNode.methodData.isKtoK() ? "k-k wormhole" : "wormhole chain";
		}

		var breakChain = (partition.length === 2
			&& (currentMethodType === "k-k wormhole" || currentMethodType === "bridge"));

		if (!breakChain && (!currentMethodType || currentMethodType === methodType)) {
			currentMethodType = methodType;
			partition.push(currentRouteNode);
		}
		else {
			var lastNode = partition[partition.length - 1];

			var newPartition = getNewPartition(currentMethodType, partition);
			partitionList.push(newPartition);
			partition = [];
			partition.push(lastNode);
			partition.push(currentRouteNode);
			currentMethodType = methodType;
		}
	}

	partitionList.push(getNewPartition(currentMethodType,partition));
	return partitionList;

	function getNewPartition(methodType, systems) {
		if (methodType === "bridge")
		    return new RoutePartitionBridge(partition);
		if (methodType === "k-k wormhole" || methodType === "wormhole chain")
		    return new RoutePartitionWormholes(methodType, partition);
		else
		    return new RoutePartition(currentMethodType, partition);
	}
};

RouteDetails.prototype.getWormholes = function () {
	var wormholes = this.route
        .filter(function (routeNode) { return routeNode.methodType === "wormhole"; })
        .map(function (routeNode) { return routeNode.methodData });
	return wormholes;
}

RouteDetails.prototype.getBridges = function () {
	var bridges = this.route
		.filter(function (routeNode) { return routeNode.methodType === "bridge"; })
		.map(function (routeNode) { return routeNode.methodData });
	return bridges;
}
RouteDetails.prototype.getAge = function () {
	if (this.age === undefined) {
	    var wormholes = this.getWormholes();
	    if (wormholes.length === 0)
	        this.age = null;
	    else {
	        var age;
	        wormholes.forEach(function (item) {
	            if (!age || item.getLastObserved() < age)
	                age = item.getLastObserved();
	        });
	        this.age = age;
	    }
	}
	return this.age;
}
RouteDetails.prototype.getAgeFuzzy = function () {
	var res = this.getWormholes().some(function (x) { return x.isExpired() });
	if (res) return "Expired";

	var age = this.getAge();
	if (!age) {
	    return "Static";
	}
	else {
	    return moment(age).fromNow().replace("ago", "");
	}
}
RouteDetails.prototype.getAgePretty = function () {
    return this.getAge() ? moment(this.getAge()).format("llll") : "-";
}
RouteDetails.prototype.getDateExpires = function () {
	var wormholes = this.getWormholes();
	if (wormholes.length === 0) return null;

	return wormholes.reduce(function (prev, curr) {
	    var currEnd = curr.getDateExpires();
	    return Math.min(prev, currEnd);

	}, Number.POSITIVE_INFINITY);
}
RouteDetails.prototype.getDateExpiresFuzzy = function () {
	var expires = this.getDateExpires();
	if (!expires) return "Static";
	if (expires < new Date().getTime())
	    return "Expired";

	return moment(expires).fromNow().replace("in", "");
}
RouteDetails.prototype.getDateExpiresPretty = function () {
    return this.getDateExpires() ? moment(this.getDateExpires()).format("llll") : "-";
}

RouteDetails.prototype.getFatigue = function (shipClass) {
	return _fatigueFromComponents(this.routePartition, shipClass);
}
RouteDetails.prototype.getMinutes = function (shipClass) {
	return _travelTimeFromComponents(this.routePartition, shipClass);
}

RouteDetails.prototype.getFatiguePretty = function (shipClass) {
	return this.getFatigue(shipClass).toFixed(1);
}
RouteDetails.prototype.getMinutesPretty = function (shipClass) {
	return Math.ceil(this.getMinutes(shipClass));
}


//---------------------------------------------------------------------------------------------
// Various route partitions


var RoutePartitionBridge = function (systems) {

	this.type = "bridge";
	this.startSystem = systems[0].system;
	this.endSystem = systems[1].system;
		
	this.jumps = 1;
	this.bridger = systems[1].methodData;
	this.bridgeType = this.bridger.bridgeType;

	this.distance = this.startSystem.getDistanceFromSystem(this.endSystem);
}
RoutePartitionBridge.prototype.getDistancePretty = function() {
	var pretty = this.distance.toFixed(2);
	return pretty;
}


var RoutePartitionWormholes = function (type, systems) {
	this.type = "wormhole";
	this.subtype = type;
	this.systems = systems;
	this.jumps = systems.length - 1;
	this.startSystem = this.systems[0].system;
	this.endSystem = this.systems[this.systems.length - 1].system;
	this.wormholes = systems.slice(1).map(function (x) {
	    return x.methodData;
	});

	this.missingClass = this.wormholes.some(function (x) { return !x.hasClass() });
}

var RoutePartition = function (type, systems) {
	this.type = type;
	this.systems = systems;
	this.jumps = systems.length - 1;
	this.startSystem = this.systems[0].system;
	this.endSystem = this.systems[this.systems.length - 1].system;
}

function _fatigueFromComponents(routePartition, shipClass) {
	var fatigue = 0;
	for (var i = 0; i < routePartition.length; i++) {
		var part = routePartition[i];
			
		if (part.type === "bridge") {
			if (part.bridgeType === "blackops")
				fatigue = _calcFatigue(fatigue, part.distance, 0.5);
			else
				fatigue = _calcFatigue(fatigue, part.distance, 1);
		}
		else {
			var travelTime = _jumpsToMinutes(part.jumps, shipClass);
			var fatigueLoss = travelTime / 10;
			fatigue = Math.max(0, fatigue - fatigueLoss);
		}
	}
	return fatigue;
}

function _travelTimeFromComponents(routePartition, shipClass) {
	var fatigue = 0;
	var travelTime = 0;

	for (var i = 0; i < routePartition.length; i++) {
		var part = routePartition[i];

		if (part.type === "bridge") {
			travelTime += fatigue + _jumpsToMinutes(1, shipClass);
			if (part.bridgeType === "blackops")
				fatigue = _calcFatigue(fatigue, part.distance, 0.5);
			else
				fatigue = _calcFatigue(fatigue, part.distance, 1);
		}
		else {
			var partTravelTime = _jumpsToMinutes(part.jumps, shipClass);
			travelTime += partTravelTime;
			var fatigueLoss = partTravelTime / 10;
			fatigue = Math.max(0, fatigue - fatigueLoss);
		}
	}
	return travelTime;
}

function _jumpsToMinutes(numJumps, shipClass) {;
	var secondsPerJump = shipClass.alignTime + shipClass.warpTime20;
	secondsPerJump += 10 // session change, etc. 
		
	return (secondsPerJump * numJumps) / 60;
}

function _calcFatigue(existingFatigue, distance, multiplier) {
	var out;

	var newFatigue = 1 + (distance * multiplier);

	if (existingFatigue < 1)
		out = newFatigue;
	else
		out = newFatigue * existingFatigue;
	return out;
}


module.exports = RouteDetails;