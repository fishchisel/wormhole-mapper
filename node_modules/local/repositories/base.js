'use strict';

var q = require('q'),
    Firebase = require('firebase');

var rootRef;

/**
 * Provides some base implementation helpers for accessing firebase
 * config: {
 *   // path of the table in the DB
 *   path: 'wormholes',  
 * 
 *   // Optional. Given an id and an obj from the db, should return an obj that goes into the
 *   // local store. (default: returns DB object)  
 *   makeLocal : function(id,remoteData) {}, 
 * 
 *   // Optional. Given a local representation, should return an obj that can go into the DB.
 *   // (default: returns local reprentation)
 *   makeRemote: function(localData) {},
 * 
 *   // Optional. given a local data object, should return that object's id. 
 *   // (default: returns localData.id)
 *   idFromLocal: function(localData) {},
 * 
 *   // Optional. Given a local data object, returns whether that object is allowed into the DB
 *   isValid: function(localData) {},
 *
 *   // Optional. If true, JSON items have any 0/null/undefined keys removed before they are
 *   // sent to the DB
 *   pruneRemote: true,
 * }
 */
var baseRep = function (config) {

    var _ref;
    function ref() {
        if (!rootRef) throw new Error("You must first set the firebase URL");
        if (!_ref) _ref = rootRef.child(config.path);
        return _ref;
    }

	var makeLocal = config.makeLocal ? config.makeLocal : function (a, b) { return b; };
	var makeRemote = config.makeRemote ? config.makeRemote : function (a) { return a; };
	var idFromLocal = config.idFromLocal ? config.idFromLocal : function (a) { return a.id; };
	var isValid = config.isValid ? config.isValid : function (a) { return true; };

	if (config.pruneRemote) {
	    var oldMakeRemote = makeRemote;
	    makeRemote = function (a) {
	        var res = oldMakeRemote(a);
	        return clearEmpty(res);
	    };
	}

	function clearEmpty(obj) {
	    for (var key in obj) {
	        if (!obj[key]) delete obj[key];
	        if (typeof (obj[key]) == "object") clearEmpty(obj[key]);
	    }
	    return obj;
	}

	var repObj = {};
	var repArray = [];
	var changedHandlers = [];

	var initializingDeferred;

	var supressChanged = false;
	var hasQueuedChanges = false;

	var localData = { hash: {}, array: [] };
	var remoteData = null;

	var me = {};

    me.get = function (id) {
		return me.getAll()[id];
	}
	me.getAll = function () {
		if (remoteData) {
			localData = _createLocalData(remoteData);
			remoteData = null;
		}
		return localData.hash;
	}
	me.getArray = function () {
		if (remoteData) {
			localData = _createLocalData(remoteData);
			remoteData = null;
		}
		return localData.array;
	}

	me.create = function (data) {
		if (!isValid(data)) throw "Invalid data";

		var newRef = ref().push(makeRemote(data));
		return newRef.key()
	};
	me.update = function (data) {
		if (!isValid(data)) throw "Invalid data";

		var id = idFromLocal(data);
		if (!id)
			me.create(data);
		else
			ref().child(id).set(makeRemote(data));
	};
	me.delete = function (data) {
		var id = idFromLocal(data);
		ref().child(id).remove();
	}

	me.changed = function (handler) {
		if (handler !== undefined)
			changedHandlers.push(handler)
		else {
			if (supressChanged) return;
			changedHandlers.forEach(function (item) {
				item();
			});
		}
	};
	me.changedRemoveHandler = function (handler) {
		changedHandlers.remove(handler);
	};
	me.supressChanged = function (state) {
		if (state !== supressChanged) {
			supressChanged = state;

			if (!state && hasQueuedChanges) {
				hasQueuedChanges = false;
				me.changed();
			}
		}
	}
	me.getSupressChanged = function () {
		return supressChanged;
	}

	var _createLocalData = function (dbData) {
		var obj = {};
		var arr = Object.keys(dbData).map(function (key) {
			var outData = makeLocal(key, dbData[key]);
			obj[key] = outData;
			return outData;
		});

		return { hash: obj, array: arr };
	}

	me.initialize = function () {

	    if (!initializingDeferred) {
	        initializingDeferred = q.defer();
            
			var initial = true;
			ref().on('value', function (dbData) {
				var data = dbData.val();

				remoteData = data ? data : {};

				if (!supressChanged && !initial) {
					me.changed();
				}
				else if (supressChanged) {
					hasQueuedChanges = true;
				}
				else if (initial) {
					initial = false;
					initializingDeferred.resolve();
				}
			}, function (err) {
			    console.log("firebase init error:", err);
			    initializingDeferred.reject();
			    initializingDeferred = null;
			});
		}
		return initializingDeferred.promise;
	}

	return me;
};

baseRep.setFirebaseUrl = function (url) {
    rootRef = new Firebase(url);
}
baseRep.getRef = function () {
    if (!rootRef)
        throw new Error("Must set firebase url");
    return rootRef;
}

var staticDataRoot = "./";
baseRep.setStaticDataRoot = function (inp) {
    staticDataRoot = inp;
}
baseRep.getStaticDataRoot = function () {
    return staticDataRoot;
}

module.exports = baseRep;


