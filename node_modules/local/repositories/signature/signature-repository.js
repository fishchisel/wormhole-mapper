'use strict';

var q = require('q');

var Signature = require('./signature');
var baseRepository = require('../base'),
    userRepository = require('../user');



var sigsForSystemCache = {};

var base = baseRepository({
	path: 'signatures',
	makeLocal: function (id, data) {
		return new Signature(data);
	},
	makeRemote: function (args) {
		var signatureJson = {
			id: args.id.toUpperCase(),
			systemId: parseInt(args.systemId),
			type: args.type ? args.type : null,
			wormholeId: args.wormholeId ? args.wormholeId : null,
			dateFound: args.dateFound ? args.dateFound : new Date().getTime(),
			lastScanned: args.lastScanned ? args.lastScanned : new Date().getTime(),
			lastModified: new Date().getTime(),
			note: args.note && args.note.length <= 140 ? args.note : null,
			log: args.log ? args.log : {}
		}
		return signatureJson;
	},
	idFromLocal: function (data) {
		return data.systemId + "_" + data.id.toUpperCase();
	},
	isValid: function (data) {
		return data.systemId && data.id;
	}
});

var me = {
	getSignature: base.get,
	getSignatures: base.getAll,
	getSignaturesArray: base.getArray,
	createSignature: base.update,
	updateSignature: base.update,
	deleteSignature: base.delete,
	signaturesChanged: base.changed,
	signaturesChangedRemoveHandler: base.changedRemoveHandler,
	//initialize: base.initialize,
	supressChanged: base.supressChanged
};

me.initialize = function () {
    var sInit = base.initialize();
    var usInit = userRepository.initialize();

    return q.all([sInit, usInit]);
}

me.signaturesChanged(function () {
	sigsForSystemCache = {};
});

me.getSignaturesForSystem = function (system) {

	var id = system.id;

	if (sigsForSystemCache[id] === undefined) {
		sigsForSystemCache[id] = me.getSignaturesArray().filter(function (sig) {
			return sig.systemId == id;
		});
	}
	return sigsForSystemCache[id];
}
me.invalidateCache = function () {
	sigsForSystemCache = {};
}

module.exports = me;


